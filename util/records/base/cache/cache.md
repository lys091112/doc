# 关于cache的记录



- 缓存风暴
    在某一时刻，大量的缓存集体失效，造成同一key大量访问到数据库层
    解决方式：
        1. 随机过期时间，保证key不会同时失效
        2. 添加同步机制，保证key只有一次访问到数据库
        3. 不设置失效时间，起后台线程定时更新数据
        4. 设置二级缓存，一级失效后访问二级，同时更新一级缓存(TODO 待深思)
- 缓存穿透
    表现为如果缓存中没有，则去查询数据库中的数据。 
    解决方式：
        1. 将空对象存入到缓存中，对于不存在的key，直接返回
        2. 加一层bloomfilter过滤（如果key不存在，则一定不存在，如果key存在，则有很大的概率存在)
- 缓存更新


**方式**：
- 异步提前更新
- 




#### 一些使用记录

1. 对于依赖第三方的数据，如何保证当第三方挂掉时，不影响己方的正常执行

```
告警邮件发送中，对象内容依赖与业务方提供的数据，但当业务方宕掉时，为不影响己方的正常运行
应将业务方的对象数据存储起来(这部分数据基本情况下是不会改变的)，以一定的周期去定时更新，
如果更新失败，那么再经过一个周期再次更新，再尽可能保证业务数据准确性的同时，也要保证自身服务的可靠性。

当然最好的方式是：己方存储业务方的对象数据，当业务对象数据变化时，通过接口修改己方数据

```
