# Java

## JVM 优化
一些可能导致内存溢出的原因
    - 堆内存设置太小
    - 永久代设置太小(java8已不存在这个问题,因为metaspace已经替代了perm)
    - 代码中创建了很多大对象 , 且一直因为被引用不能被回收
    - 长生命周期对象持有短生命周期对象的引用
    - 静态集合类引起的内存泄漏 , 例如HashMap和Vector等  因为他们是静态的, 他们的生命周期与应用一致 , 所以他们引用的对象不会被释放 , 所以需要特别注意自己是否有静态集合存了许多对象的情况
    - 单例模式 单例对象初始化后再JVM整个生命周期中存在 , 如果单例对象持有对外部对象的引用那么整个对象不会被JVM回收
    - 全局集合
    - 类加载器 


1. 代码中创建了很多大对象 , 且一直因为被引用不能被回收

```
    0) 使用jstat查看gc情况
    1) 使用jmap -heap pid查看堆使用情况
    2) 使用jmap -histo:live pid 查看实例数和实例所占内存大小
    3) 第三步, 统计所有实例所占内存大小 jmap -histo:live 17863|awk ‘{if(NR>3)a+=\$3}END{print a}’ 

```

2.  java进程高负载问题排查

```
    - 执行top -c命令，找到cpu最高的进程的id
    - 使用top -H -p #{pid} 命令，查看当前java进程中的各线程的资源使用情况；
    - 找出负载高的线程，记录pid（26507）；
    - 使用printf "%x\n" 26507命令，将线程的pid（26507）转换为16进制字符串（678b）；
    - 在jstack -l pid 导出的java进程的堆栈信息中，查找字符串678b，即可定位负载高的线程的堆栈信息
```


## JVM 基础

1. java new一个对象的执行过程

```
    1. 虚拟机先执行class文件
    2. 执行class类的static静态代码
    3. 开堆内存开辟空间，分配地址
    4. 在堆内存中建立对象的特有属性（成员变量），并进行默认初始化
    5. 对属性进行显示初始化
    6. 对对象a进行构造初始化
    7. 将内存地址传递给a
```

2. 类的生命周期
类加载一般分为加载，连接，初始化三个阶段·
```
    1. 加载
        - 通过一个类的全限定名来获取定义此类的二进制字节流。
        - 将这个字节流代表的静态存储结构转化为为方法区的运行时数据结构。
        - 在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类各种数据的访问入口。
    2. 连接
        - 验证
            1. 文件格式验证。 包括是否以0xCAFFBABE开头，版本号是否可以当前虚拟机执行，常量池常量类型是否支持等等。。。
            2. 元数据验证。 针对语义分析，是否有父类，父类是否继承了不允许继承的类是否抽象，子类是否是实现接口中的方法等等。。
            3. 字节码验证。 确认数据流和控制流分析远程是合法的，并对类的方法进行校验，保证类方法在运行期间不会做出危害虚拟机安全的事件
            4. 符号引用。  将符号引用转化为直接引用，对引用做匹配性校验。如方法的访问性，是否可以通过全量名找到对应的类
        - 准备
            1. 正式为类变量分配内存并设置类变量的初始值
            2. 这个分配内存的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量会在对象实例化时随着对象一起配置到java堆中。例如： 

        - 解析 将常量池内的符号引用替换为直接引用的过程
            1. 类和接口解析
            2. 字段解析
            3. 类方法解析
            4. 接口方法解析


    3. 初始化
        类的初始化:有且只有的5种对类初始化的情况
        1. 遇到 new, putstatic, getstatic, invokestatic 这四个指令时，需要先触发类的初始化。 关键字的常用场景： 使用new初始化实例对象，获取静态
        变量，为静态变量赋值时（被final修饰的除外，已经被放到常量池中），  掉哟过一个类静态方法时
        2. 使用 java.lang.reflect 对类进行反射调用的时候，如果类没有初始化，则触发初始化
        3. 当初始化一个类的时候，如果父类没有初始化，会先初始化父类
        4. 虚拟机启动时，需要用户指定一个主类（包含main方法的类）， 虚拟机会先初始化这个主类
        5. 使用ＪＤＫ1.7动态语言支持时， 如果一个java.lang.invoke.MethodHandle 实例最后的解析结果是REF_static, REF_putstatic, REF_invokestatic
        的方法句柄，并且这个方法没有被初始化，则需要先进行初始化


```

3. 类卸载条件
```
    - 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。
    - 加载该类的ClassLoader已经被回收。
    - 该类对应的java.lang.Class对象没有任何地方被引用，没有在任何地方通过反射访问该类的方法。
```

4. 可作为GCROOT的对象有：
```
    - 虚拟机栈中引用的对象
    - 方法区中静态属性引用的对象
    - 方法区中常量引用的对象
    - 本地方法栈中JNI引用的对象
```

5. 四种引用对象
```
    强引用： 只要引用还存在，那么就不会被垃圾收集器回收
    软引用： 有用但非必须的对象 在系统简要发生内存溢出异常之前，会把这些对象列入回收范围进行二次回收，如果仍不够，才会抛出内存溢出。 java类为：SoftReference
    弱引用： 被虚引用关联的对象只能生存到下一次垃圾回收之前。垃圾回收器工作后，无论内存是否足够，都会将该类对象进行收集。java类： WeakReference
    虚引用： 存在的唯一目的是在进行垃圾回收之前，收到一个系统通知，被虚引用关联的对象和其生存时间完全没有关系。java类： PhantomReference  例如：DirectByteBuffer中的Cleaner就是一个虚引用，在进行垃圾回收时会收到通知进而调用run方法对堆外内存进行回收
```

# Collection

1. ArrayLIst 扩容过程 

```
    - ArrayList动态扩容的全过程。如果通过无参构造的话，初始数组容量为0，当真正对数组进行添加时，才真正分配容量。每次按照1.5倍（位运算）的比率通过copeOf的方式扩容。 在JKD1.6中实现是，如果通过无参构造的话，初始数组容量为10，每次通过copeOf的方式扩容后容量为原来的1.5倍，以上就是动态扩容的原理。
```

2. hashMap 扩容
```
    初始容量定义：默认为1 << 4（16）。最大容量为1<< 30。
    扩容加载因子为(0.75)，第一个临界点在当HashMap中元素的数量等于table数组长度*加载因子（16*0.75=12）， 如果超出则按oldThr << 1（原长度*2）扩容
```

3. HashSet 扩容
```
    - 初始容量定义：16。因为构造一个HashSet，其实相当于新建一个HashMap，然后取HashMap的Key。 扩容机制和HashMap一样
```
4. hashtable 扩容
```
    - 初始容量定义：capacity (11)
    - 扩容加载因子(0.75)，当超出默认长度（int）（11*0.75）=8时，扩容为old*2+1。 int newCapacity = (oldCapacity << 1) + 1
```


## Java并发

1. java 并发中常见的几种锁机制

锁的状态总共有四种：无锁状态、偏向锁、轻量级锁和重量级锁。随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁（但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级）。JDK 1.6中默认是开启偏向锁和轻量级锁的，我们也可以通过-XX:-UseBiasedLocking来禁用偏向锁

“轻量级” 是相对于使用操作系统互斥量来实现的传统锁而言的。但是轻量级锁并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用产生的性能消耗。轻量级锁所适应的场景是线程交替执行同步块的情况，如果存在同一时间访问同一锁的情况，就会导致轻量级锁膨胀为重量级锁

   - 偏向锁 核心的思想是，如果程序没有竞争，则取消之前已经取得锁的线程同步操作。也就是说，若某一锁被线程获取后，便进入偏向模式，当线程再次请求这个锁时，就无需再进行相关的同步操作了，从而节约了操作时间，如果在此之间有其他的线程进行了锁请求，则持有偏向锁的线程会被挂起，JVM尝试消除它身上的偏向锁，将锁恢复到标准轻量级锁。在JVM中使用-XX:+UseBiasedLocking 禁用偏向锁. 在线程竞争比较严重的程序中，可以禁用偏向锁，减少锁升级性能消耗


   - 如果偏向锁失败，轻量级锁（Lightweight Locking）利用了CPU原语Compare-And-Swap(CAS，汇编指令CMPXCHG)，尝试在进入互斥前，进行补救，减少多线程进入互斥的几率。 如果偏向锁失败，那么系统会进行轻量级锁的操作，使用CAS操作来尝试加锁。如果轻量级锁失败，才调用系统级别的重量级锁（syncrhoized）来加锁


   - 重量级锁 Synchronized是通过对象内部的一个叫做监视器锁（monitor）来实现的。但是监视器锁本质又是依赖于底层的操作系统的Mutex Lock来实现的。而操作系统实现线程之间的切换这就需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么Synchronized效率低的原因。因此，这种依赖于操作系统Mutex Lock所实现的锁我们称之为“重量级锁”。JDK中对Synchronized做的种种优化，其核心都是为了减少这种重量级锁的使用。JDK1.6以后，为了减少获得锁和释放锁所带来的性能消耗，提高性能，引入了“轻量级锁”和“偏向锁”
       

   - 自旋锁 当线程申请锁时，锁被占用，则让当前线程执行一个忙循环（自旋），看看持有锁的线程是否会很快释放锁。如果自旋后还没获得锁，才进入同步阻塞状态


**锁的基本升级过程:**
```
线程1当前拥有偏向锁对象,线程2是需要竞争到偏向锁
    - 线程2来竞争锁对象;
    - 判断当前对象头是否是偏向锁;
    - 判断拥有偏向锁的线程1是否还存在;
    - 线程1不存在,直接设置偏向锁标识为0(线程1执行完毕后,不会主动去释放偏向锁);
    - 使用cas替换偏向锁线程ID为线程2,锁不升级，仍为偏向锁;
    - 线程1仍然存在,暂停线程1；
    - 设置锁标志位为00(变为轻量级锁),偏向锁为0;
    - 从线程1的空闲monitor record中读取一条,放至线程1的当前monitor record中;
    - 更新mark word，将mark word指向线程1中monitor record的指针;
    - 继续执行线程1的代码;
    - 锁升级为轻量级锁;   
    - 线程2自旋来获取锁对象;

如果判断一个线程是否存在：(分析thread.cpp)
    - 线程执行start时，会将自己写入一个thread_list中,这是一个linked结构，有pre和next节点;
    - 线程执行完后,会将自己从thread list中清理掉(源码位置: Threads::remove(this)); 因此只需判断thread list中是否存在线程1即可
```

**优化策略:**
```
    1. 减少锁的持有时间。 例如缩小锁的范围
    2. 减小锁的粒度。 例如concurrenthashmap 将数据分为几个segment，分别锁
    3. 锁分离。 读写锁的性质，读锁之间不会相互互斥，提高并发性
    4. 锁粗化。 如果不连续的代码段频繁使用锁，可以将其合并为一个，减少锁切换消耗
    5. 锁消除。 这是编译器自带的优化措施    
```

2. 线程池的使用
   - **ThreadPoolExecutor参数信息**

        | 参数名 | 作用|
        |-------|-------|
        | corePoolSize | 核心线程池大小|
        | maximumPoolSize| 最大线程池大小 |
        | keepAliveTime| 线程池中超过corePoolSize数目的空闲线程最大存活时间 |
        | timeUnit | keepAliveTime时间单位 |
        | workQueue| 阻塞任务队列|
        | threadFactory | 新建线程工程，常用来制定线程名称等 |
        | RejectedExecutionHandler | 当提交任务数超过maxmumPoolSize+workQueue之和时，任务会交给RejectedExecutionHandler来处理 |

    - **corePoolSize, workQueue, maximumPoolSize 的关系**

        ```
        有新的任务时：
            当线程数小于核心线程数时，创建新线程,无需进入队列等待
            当线程数大于等于核心线程数，且任务队列未满时，将任务放入任务队列，此时不会创建新线程。
            当线程数大于等于核心线程数，且任务队列已满
            若线程数小于最大线程数，创建新线程
            若线程数等于最大线程数，抛出异常，拒绝任务
        ```

3. 创建线程的3种方式
```
    1. new Thread 类
    2. 继承Runnable接口
    3. 继承Callable接口，可以通过FutureTask来获取执行结果
```

## java IO

1. 对外内存
```
常使用的申请方式： ByteBuffer.allocteDirect(XXXX)

```
2. 堆外内存的使用
```
堆外内存申请的两种方式：
1. ByteBuffer.allocateDirect(xxx)
这种申请会在进行垃圾回收时被jvm回收

2. unsafe.allocateMemory(xx)
这种申请方式需要手动进行垃圾回收
```


## java 其他

1. ThreadLocal 内存泄漏问题
```
ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没有外部强引用来引用它，那么系统 GC 的时候，这个ThreadLocal势必会被回收，这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：Thread Ref -> Thread -> ThreaLocalMap -> Entry -> value永远无法回收，造成内存泄漏。

ThreadLocalMap是被设置到thread中，是thread的一个成员变量，key为threadlocal， value为引用的值

其实，ThreadLocalMap的设计中已经考虑到这种情况，也加上了一些防护措施：在ThreadLocal的get(),set(),remove()的时候都会清除线程ThreadLocalMap里所有key为null的value。

但是这些被动的预防措施并不能保证不会内存泄漏：
    使用static的ThreadLocal，延长了ThreadLocal的生命周期，可能导致的内存泄漏
    分配使用了ThreadLocal又不再调用get(),set(),remove()方法，那么就会导致内存泄漏。


原因主要为： 由于ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除对应key就会导致内存泄漏，而不是因为弱引用

因此在使用threadLocal时需要注意：每次使用完ThreadLocal，都调用它的remove()方法或者set(null)，清除数据
像使用lock一样每次都手动进行unlock，防止内存泄漏

```
