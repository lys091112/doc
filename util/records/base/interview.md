## 数据库方面

1. 数据库设计的三大范式

    第一范式是最基本的范式。如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库表满足了第一范式, 例如地址可以拆分为省份，城市，详细地址多个部分

    第二范式： 首先是第一范式，另外包含两部分内容，一是表必须有主键，二是没有包含在主键中的列必须完全依赖与主键，而不能只依赖主键的一部分
    例如：订单明细表：OrderDetail（OrderId, ProductId,单价，折扣，数量，产品名称），对于一个订单它可能有多个商品，那么单单一个OrderId不足以做主键，因此会使用OrderId和ProductId做为联合主键。 折扣，数量是严格与联合主键关联，但是单价，产品名称却只和ProductId相关，因此不满足2NF，所以需要将单价和产品名称拆到一张单独的表中，防止在订单详情表中多余产品信息的冗余（因为如果每个订单都包含订单单价和订单名称，那么多个订单会重复出现该数据，造成冗余）。但是也有意外情况，即我需要单价和产品名称来做历史记录，防止产品信息更改后造成历史数据的丢失

    第三范式： 首先是2NF，其次非主键列必须直接依赖于主键列，而不能存在传递依赖，即不能存在A列依赖于B列，B列依赖于主键列
    例如订单表：Order（OrderID，createTime, customerId, customerName, customerAddr),其中OderID是主键，其他列都于主键相关，但是CustomerName，customerAddr于customerId直接相关，而并非于orderId直接相关，因此不满足3NF，需要将数据库表进行拆分 其他： BCNF： 
    第四范式：要求把同一表内的多对多关系删除
    五范式：从最终结构重新建立原始结构？？


2. 数据库设计过程中有那些注意事项或者优化原则

- 库设计：
     数据库名称要明确，可以加前缀或后缀，要有业务含义
     不同类型的数据应分开管理，如财务数据，业务数据
     尽可能少用存储过程，不要让数据库处理过多逻辑，将业务放到应用中

- 表设计：
   - 数据尽量不要进行物理删除，应添加一个标志位，以防用户后悔时无法恢复
   - 数据添加是否有效的标识位
   - 字段排序 将数据库字段按照一定的规则进行排序，方便查找
   - 是否需要记录时间，创建时间和更新时间等
   - 数据库字段尽可能添加默认值
   - 如果两个表存在多对多的关系，尽可能在添加一张关联表，将其转化为一对多的关系
   - 表的垂直拆分，经常查询的字段放置到一个表中，把text， blob类型的数据拆分到另一个表中
   - 禁止使用select (*)这样的查询

   索引：
    索引需要根据where groupby等语句后的条件按照一定的顺序进行排列
    索引的个数需要控制在3个以内
    对于字符串索引，需要添加索引的长度控制，防止索引太大，占据太多空间

索引的弊端: 一是创建索引要耗费时间，二是索引要占有大量磁盘空间，三是增加了维护代价（在修改带索引的数据列时索引会减缓修改速度）

3. Mysql数据库有哪几种引擎，各自的特性是什么

+-------------+------+----------------------+-------------------------------+------------------------+
| 存储引擎    | 事务 | 锁粒度               | 主要应用                      | 忌用                   |
+=============+======+======================+===============================+========================+
| MyISAM      | No   | 支持并发插入的表级锁 | SELECT，INSERT                | 读写操作频繁           |
+-------------+------+----------------------+-------------------------------+------------------------+
| MRG-MyISAM  | No   | 支持并发插入的表级锁 | 分段归档，数据仓库            | 全局查找过多的场景     |
+-------------+------+----------------------+-------------------------------+------------------------+
| Innodb      | Yes  | 支持MVCC级别的行级锁 | 事务处理                      | 无                     |
+-------------+------+----------------------+-------------------------------+------------------------+
| Archine     | No   | 行级锁               | 日记记录，只支持insert select | 需要随机读取 更新 删除 |
+-------------+------+----------------------+-------------------------------+------------------------+
| NDB Cluster | Yes  | 行级锁               | 高可用                        | 大部分应用             |
+-------------+------+----------------------+-------------------------------+------------------------+

Innodb引擎提供了对数据库ACID事务的支持，并且实现了SQL标准的四种隔离级别，关于数据库事务与其隔离级别的内容请见数据库事务与其隔离级别这篇文章。该引擎还提供了行级锁和外键约束，它的设计目标是处理大容量数据库系统，它本身其实就是基于MySQL后台的完整数据库系统，MySQL运行时Innodb会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎不支持FULLTEXT类型的索引，而且它没有保存表的行数，当SELECT COUNT(*) FROM TABLE时需要扫描全表。当需要使用数据库事务时，该引擎当然是首选。由于锁的粒度更小，写操作不会锁定全表，所以在并发较高时，使用Innodb引擎会提升效率。但是使用行级锁也不是绝对的，如果在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表

MyIASM是MySQL默认的引擎，但是它没有提供对数据库事务的支持，也不支持行级锁和外键，因此当INSERT(插入)或UPDATE(更新)数据时即写操作需要锁定整个表，效率便会低一些。不过和Innodb不同，MyIASM中存储了表的行数，于是SELECT COUNT(*) FROM TABLE时只需要直接读取已经保存好的值而不需要进行全表扫描。如果表的读操作远远多于写操作且不需要数据库事务的支持，那么MyIASM也是很好的选择

大尺寸的数据集趋向于选择InnoDB引擎，因为它支持事务处理和故障恢复。数据库的大小决定了故障恢复的时间长短，InnoDB可以利用事务日志进行数据恢复，这会比较快。主键查询在InnoDB引擎下也会相当快，不过需要注意的是如果主键太长也会导致性能问题，关于这个问题我会在下文中讲到。大批的INSERT语句(在每个INSERT语句中写入多行，批量插入)在MyISAM下会快一些，但是UPDATE语句在InnoDB下则会更快一些，尤其是在并发量大的时候

InnoDB：磁盘表，支持事务，支持行级锁，B+Tree索引
ps:优点： 具有良好的ACID特性。适用于高并发，更新操作比较多的表。需要使用事务的表。对自动灾难恢复有要求的表。
缺点：读写效率相对MYISAM比较差。占用的磁盘空间比较大。

MyISAM：磁盘表，不支持事务，支持表级锁，B+Tree索引
ps: 优点：占用空间小，处理速度快（相对InnoDB来说）
缺点：不支持事务的完整性和并发性

MEMORY(Heap)：内存表，不支持事务，表级锁，Hash索引，不支持Blob,Text大类型
ps: 优点：速度要求快的，临时数据
缺点：丢失以后，对项目整体没有或者负面影响不大的时候。

4. 其他
    useServerPrestmts=true 开启PreparedStatemeng的缓存

##  nosql

1. 什么是nosql

2. 为什么nosql比sql快？
    Nosql是非关系型数据库，因为不需要满足关系数据库数据一致性等复杂特性所以速度快；
    sql是关系型数据库，功能强大，但是效率上有瓶颈

3. 

## ZK+Kafka
1. 为什么kafka需要使用zkeeper， 能够替代zk

    kafka需要一个地方存储元数据以及交换集群信息，使用zookeeper的watch机制来发现meta的变更以及做出相应的动作
    kafka broker启动后会在zk建立一个临时节点(当broker挂掉后，删除该临时节点),随后向broker注册自己持有的topic和partitions
    consumer and consmergroup 一个group中的多个consumer可以交错的消费一个topic的所有partitions;简而言之,保证此topic的所有partitions都能被此group所消费,且消费时为了性能考虑,让partition相对均衡的分散到每个consumer上
    
状态同步：
    consmer 保存消费的offset到zookeeper
    partition leader 注册在zk中，Producer作为client，通过注册Watch用来监听partition leader的变更事件
    zk支持kafka的partition leader／follower的协同和选举，保证partition中只要有leader／follower就不会停止服务


总结：
    Producer通过zk来发现borker列表，并通过于topic下的每个partition leader建立连接关系并发送消息
    Borker用zk来注册borker信息，以及检测partion leader的存活性
    Consumer使用zk来组成consumer信息，包括consumer消费的partition信息等，同时也可以用来发现borker列表，并同partitionleader建立连接来消费信息


换言之需要知道现在那些生产者（对于消费者而言，kafka就是生产者）是可用的。 如果没了zk消费者如何知道呢？如果每次消费者在消费之前都去尝试连接生产者测试下是否连接成功，效率呢？ 所以kafka需要zk，在kafka的设计中就依赖了zk了

2. ZK的使用场景有哪些
    
    常见的使用场景包括：配置管理， 统一命名服务，提供分布式同步，集群管理

3. ZK的特性，包括Watch之类的特性

3. kafka与其他消息队列的对比，为什么告警使用kafka而不使用其他队列
