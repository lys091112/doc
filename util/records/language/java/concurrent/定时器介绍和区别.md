# java 中常使用的任务定时处理

## Timer

Timer 根据任务的执行时间维护了一个优先队列，并且起了一个线程不断地拉取任务执行。 
缺点：  1. 单线程处理，一个任务执行的时间过久则会影响下一个任务的执行时间
       2. 代码可以看到对异常没有做什么处理，一个任务出错的时候会导致之后的任务都无法执行
       3. 优先队列的插入和删除的时间复杂度是O(logn)，当数据量大的时候，频繁的入堆出堆性能有待考虑


## SchedulerThreadPool

类似于Timer的多线程版本，并对异常进行catch处理，一个异常不会影响其他任务的调用，插入和删除的时间复杂度是O(logn),不太适合大量任务频繁的更新执行


## DelayQueue

利用优先队列实现的，元素通过实现 Delayed 接口来返回延迟的时间。不过延迟队列就是个容器，需要其他线程来获取和执行任务

以上3种在用在低频的小任务时没问题，但因为都是利用优先队列，时间复杂度O(longn),因此不适合与处理频繁任务


## 时间轮 TimeWheel


### 增加轮次时间轮

一层固定时间轮，记录每个数据被触发需要经过几个循环，然后在执行过程中更新所余循环次数来确定任务的执行

缺点： 会引起很多无用的 tick 推进


### 多层次的时间轮

参照钟表时分秒指针，分为多轮时间。 Kafka使用的这种方式，解决了上述时间轮的空推进问题


## 参考地址：
[时间轮算法](https://juejin.im/post/6861118085739331591#heading-3)