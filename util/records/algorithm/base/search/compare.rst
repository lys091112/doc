.. _records_algorithm_base_search_compare:

常见的搜索算法对比
====================

搜索是关于选择的，而非地图的


+---------------------+-----------------------+------------------------+------------+
| name                | backing-forward(回溯) | extend queue(拓展队列) | 启发式搜索 |
+=====================+=======================+========================+============+
| 全量遍历            | X                     | X                      | X          |
+---------------------+-----------------------+------------------------+------------+
| DFS(深度遍历)       | √                     | √                      | X          |
+---------------------+-----------------------+------------------------+------------+
| BFS(广度遍历)       | X                     | √                      | X          |
+---------------------+-----------------------+------------------------+------------+
| climbing(爬山法)    | √                     | √                      | √          |
+---------------------+-----------------------+------------------------+------------+
| seam search(束搜索) | X                     | √                      | √          |
+---------------------+-----------------------+------------------------+------------+

``TIPS:``

::
    
    1. climbing是对于深度优先搜素的扩展， 而束是对广度优先搜索的拓展
    2. 拓展队列的主要作用是记录已经拓展过的队列，然后不再对其进行拓展（可以称之为剪枝）
    3. 爬山法的缺点： 1） 可能陷入局部最优解 2）如果选取点四个方向的梯度都一致，可能陷入选择困难 3）可能四个方向都是梯度下降，只有某个方向才是梯度上升


Pseudocode
::::::::::::


.. code-block:: java

    public void search() {
        initQueue(); // 初始化队列，加入
        extendQueue() // 
    }

    public void extendQueue() {
        //1 检测搜索是否已经完成

        //2 拓展第一个路径，检测他是否被拓展过，如果拓展过，则找寻下一个节点

        //3 enQueue() 
        enQueue()
    }

    public void enQueue() {
        // 节点入队列，然后重新拓展队列
        // 1. 深度优先搜索： 入队列头部
        // 2. 广度优先搜索： 入队列尾部
        // 3. 爬山法 排序后 放入队列头部
        // 4. 束搜索 keep 束宽最佳

        extendQueue()
    }



分支界限
'''''''''

分支限界法的算法思想:

从根开始，常以广度优先或以最小耗费（最大效益）优先的方式搜索问题的解空间树。
首先将根结点加入活结点表（用于存放活结点的数据结构）, 接着从活结点表中取出根结点，使其成为当前扩展结点，一次性生成其所有孩子结点，判断孩子结点是舍 弃还是保留，舍弃那些导致不可行解或导致非最优解的孩子结点，其余的被保留在活结点表中, 再从活结点表中取出一个活结点作为当前扩展结点，重复上述扩展过程，直到找到所需的解或活结点表为 
空时为止。由此可见，每一个活结点最多只有一次机会成为扩展结点

    initial Queue ---> test first path  --> extend first path

A*
''''''''

拓展列表
    用于记录已经拓展过的节点，用于剪枝

可容许式启发
 启发式估计值能确保小雨实际距离的


A* = 分支界限 + 拓展列表(用于剪枝) + 可容许式启发(估算计算距离目标节点节点的直线距离)

``TIPS:``:

::

    可容许式启发并不总是起作用, 尤其是在多维的几何中
    H(x, G) 任意节点X同目标之间的估计距离
    D(x, G) 任意节点X同目标之间的实际距离
    Admissible: H(x,G)  <= D(x, G)
    非地图条件下，还得满足： ``|H(x, g) - H(y, g)| <= D(x, y)``

