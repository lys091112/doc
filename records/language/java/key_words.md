# java 关键字的使用和记录

- Transient

``` java
/**
  *Java的serialization提供了一种持久化对象实例的机制。当持久化对象时，可能有一个特殊的对象数据成员，我们不想   
  *用serialization机制来保存它。为了在一个特定对象的一个域上关闭serialization，可以在这个域前加上关键字transient。   
  *transient是Java语言的关键字，用来表示一个域不是该对象串行化的一部分。当一个对象被串行化的时候，
  *transient型变量的值不包括在串行化的表示中，然而非transient型的变量是被包括进去的
  *
  * 如果is前不添加transient，那么在序列化时会报异常：
  * java.io.NotSerializableException，原因是InputStream没有实现Serializable接口。
  * 
  * 有了关键字后，在反序列化时也不会赋予任何值，为null
 */

 public class ClassLib implements Serializable {
    private transient InputStream is;

    private long max;
    private long min;
 }

```

- **volatile 关键字**
```
    主要内涵：保证对线程可见，但不保证线程并发的安全性。
    volatile保证变量在工作内存和主存之间一致， 相当于告诉处理器，不要将我放在工作内存，请直接在主存中操作我

    实现原理：
        有volatile修饰的变量在编译后会多一行指令 lock XXX， lock前缀的指令在多核处理器会发生两件事：
        1). 将当前缓存行数据回写到主内存，
        2). 这个回写会引起其他cpu里缓存了该内存地址的缓存行失效，会使再次使用该数据时重新从内存加载
```
 > [引用资料:](http://blog.csdn.net/liujinwei2005/article/details/6295666)
 >   处理器为了提高处理速度，不直接和内存进行通讯，而是先将系统内存的数据读到内部缓存（L1,L2或其他）后再进行操作，但操作完之后不知道何时会写到内存，如果对声明了Volatile变量进行写操作，JVM就会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写回到系统内存。但是就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题，所以在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作的时候，会强制重新从系统内存里把数据读到处理器缓存里。
>
>   这两件事情在IA-32软件开发者架构手册的第三册的多处理器管理章节（第八章）中有详细阐述。
>
>    Lock前缀指令会引起处理器缓存回写到内存。Lock前缀指令导致在执行指令期间，声言处理器的 LOCK# 信号。在多处理器环境中，LOCK# 信号确保在声言该信号期间，处理器可以独占使用任何共享内存。（因为它会锁住总线，导致其他CPU不能访问总线，不能访问总线就意味着不能访问系统内存），但是在最近的处理器里，LOCK＃信号一般不锁总线，而是锁缓存，毕竟锁总线开销比较大。在8.1.4章节有详细说明锁定操作对处理器缓存的影响，对于Intel486和Pentium处理器，在锁操作时，总是在总线上声言LOCK#信号。但在P6和最近的处理器中，如果访问的内存区域已经缓存在处理器内部，则不会声言LOCK#信号。相反地，它会锁定这块内存区域的缓存并回写到内存，并使用缓存一致性机制来确保修改的原子性，此操作被称为“缓存锁定”，缓存一致性机制会阻止同时修改被两个以上处理器缓存的内存区域数据。
>
>    一个处理器的缓存回写到内存会导致其他处理器的缓存无效。IA-32处理器和Intel 64处理器使用MESI（修改，独占，共享，无效）控制协议去维护内部缓存和其他处理器缓存的一致性。在多核处理器系统中进行操作的时候，IA-32 和Intel 64处理器能嗅探其他处理器访问系统内存和它们的内部缓存。它们使用嗅探技术保证它的内部缓存，系统内存和其他处理器的缓存的数据在总线上保持一致。例如在Pentium和P6 family处理器中，如果通过嗅探一个处理器来检测其他处理器打算写内存地址，而这个地址当前处理共享状态，那么正在嗅探的处理器将无效它的缓存行，在下次访问相同内存地址时，强制执行缓存行填充。
```

- ** switch case**

在switch中break并不是必要的，但是如果没有break，一旦case相应的值成功，但内部没有break语句，那么将会无条件(不再进行case匹配)的继续向下执行其它case中的语句，直到遇到break;语句或者到达switch语句结束。]
