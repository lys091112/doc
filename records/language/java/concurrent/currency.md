# 多线程并发方面的一些基本问题


## 1. 线程的基本结构，以及其中的一些方法


## 2. 并发编程中的一些问题


1. 线程安全

    指某个函数、函数库在多线程环境中被调用时，能够正确地处理多个线程之间的共享变量，使程序功能正确完成

2. CAS (Compare and Swap)

    利用CPU的CAS指令，同时借助JNI来完成Java的非阻塞算法,实现原子操作, CAS 是一项乐观锁技术，
当多个线程同时更新同一个变量是，只有一个会成功。
   优点： 确保每一次的读写操作都是原子操作
   缺点： 存在3大问题： ABA问题（即刚修成成B，就被其他线程修改成A，看起来跟没有修改过一样）,
   循环时间长开销大，只能保证一个变量的原子操作
   使用总结： 
   - 使用CAS在线程冲突严重时，会大幅降低程序性能；CAS只适合于线程冲突较少的情况使用。
   - synchronized在jdk1.6之后，已经改进优化。synchronized的底层实现主要依靠Lock-Free的队列，基本思路是自旋后阻塞，竞争切换后继续竞争锁，稍微牺牲了公平性，但获得了高吞吐量。在线程冲突较少的情况下，可以获得和CAS类似的性能；而线程冲突严重的情况下，性能远高于CAS。

3. 阻塞队列

    Java7提供的无锁队列：
    - ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列。
    - LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列。
    - PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。
    - DelayQueue：一个使用优先级队列实现的无界阻塞队列。
    - SynchronousQueue：一个不存储元素的阻塞队列。
    - LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。
    - LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。


LinkedTransferQueue由链表结构组成的无界阻塞TransferQueue队列。相对于其他阻塞队列，多了tryTransfer和transfer方法
```
    transfer方法
    如果当前有消费者正在等待接收元素（take或者待时间限制的poll方法），transfer可以把生产者传入的元素立刻传给消费者。如果没有消费者等待接收元素，则将元素放在队列的tail节点，并等到该元素被消费者消费了才返回。
    tryTransfer方法
    用来试探生产者传入的元素能否直接传给消费者。，如果没有消费者在等待，则返回false。和上述方法的区别是该方法无论消费者是否接收，方法立即返回。而transfer方法是必须等到消费者消费了才返回。
    ```

