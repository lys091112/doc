# java对象内存布局

## 1. 对象组成

对象主要分为对象头和实例数据、数据填充3部分

### 1.1 对象头(Object Header):

对象头分为两部分：Mark Word 与 Class Pointer(类型指针),如果是数组类型，还会在添加length部分

Mark Word存储了对象的hashCode、GC信息、锁信息三部分，Class Pointer存储了指向类对象信息的指针。在32位JVM上对象头占用的大小是8字节，64位JVM则是16字节，两种类型的Mark Word 和 Class Pointer各占一半空间大小

在64位JVM上有一个压缩指针选项-XX:+UseCompressedOops，默认是开启的。开启之后Class Pointer部分就会压缩为4字节，此时对象头大小就会缩小到12字节

```
+--------+-----------------------+-------+----------+------------------+--------------+
| 锁状态  |         23bit         |  2bit |   4bit   | 1bit(是否偏向锁) | 2bit(锁标志) |
+--------+-----------------------+-------+----------+------------------+--------------+
| 无锁态  |        对象的Hascode          | 分代年龄 |        0         |      01      |
+--------+-------------------------------+----------+------------------+--------------+
|轻量级锁 |                   指向栈中锁记录的指针                      |      00      |
+--------+-------------------------------------------------------------+--------------+
|重量级锁|                 指向互斥量(重量级锁)的指针                  |      10      |
+--------+-------------------------------------------------------------+--------------+
| GC标记 |                              空                             |      11      |
+--------+-------------------------------------------------------------+--------------+
| 偏向锁 |     线程ID            | Epoch | 分代年龄 |        1         |      01      |
+--------|-----------------------+-------+----------+------------------+--------------+
```

### 1.2 实例数据(instance data)

实例数据里面通常只存了数据本身，但实际上这部分JVM也做了对齐填充，这样做的目的是为了内存对齐

字段重排列: 故名思义就是JVM在分配内存时不一定是完全按照类定义的字段顺序去分配，而是根据JVM选项-XX:FieldsAllocationStyle(默认是1)来进行排序

对齐的原则：
1. 对齐规则:
    上一数据结束位置 % 类型长度 == 0
需要补齐的大小
    类型长度 - 上一数据结束位置 % 类型长度

 2.子类继承父类字段的偏移量一定和父类是一致的。在具体的64位JVM实现中对还会对比子类的实例数据进行以下对齐：如果开启了压缩指针则子类第一个字段的偏移量是4N，关闭压缩指针之后是8N。

### 1.3 对齐填充

对象末尾的填充，如果对象填充完实例数据后的大小不满足"8N",则填充到8N

##  参考

[聊聊java对象内存布局](https://zhuanlan.zhihu.com/p/50984945)
[Java对象内存布局](https://ahcming.github.io/2019/01/16/java-object-memory-layout)