# 存储相关

## 1. 基础介绍
1. 数据库设计的三大范式

    第一范式是最基本的范式。如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库表满足了第一范式, 例如地址可以拆分为省份，城市，详细地址多个部分

    第二范式： 首先是第一范式，另外包含两部分内容，一是表必须有主键，二是没有包含在主键中的列必须完全依赖与主键，而不能只依赖主键的一部分
    例如：订单明细表：OrderDetail（OrderId, ProductId,单价，折扣，数量，产品名称），对于一个订单它可能有多个商品，那么单单一个OrderId不足以做主键，因此会使用OrderId和ProductId做为联合主键。 折扣，数量是严格与联合主键关联，但是单价，产品名称却只和ProductId相关，因此不满足2NF，所以需要将单价和产品名称拆到一张单独的表中，防止在订单详情表中多余产品信息的冗余（因为如果每个订单都包含订单单价和订单名称，那么多个订单会重复出现该数据，造成冗余）。但是也有意外情况，即我需要单价和产品名称来做历史记录，防止产品信息更改后造成历史数据的丢失

    第三范式： 首先是2NF，其次非主键列必须直接依赖于主键列，而不能存在传递依赖，即不能存在A列依赖于B列，B列依赖于主键列
    例如订单表：Order（OrderID，createTime, customerId, customerName, customerAddr),其中OderID是主键，其他列都于主键相关，但是CustomerName，customerAddr于customerId直接相关，而并非于orderId直接相关，因此不满足3NF，需要将数据库表进行拆分 其他： BCNF： 
    第四范式：要求把同一表内的多对多关系删除
    五范式：从最终结构重新建立原始结构？？


2. 数据库设计过程中有那些注意事项或者优化原则

- 库设计：
     数据库名称要明确，可以加前缀或后缀，要有业务含义
     不同类型的数据应分开管理，如财务数据，业务数据
     尽可能少用存储过程，不要让数据库处理过多逻辑，将业务放到应用中

- 表设计：
   - 数据尽量不要进行物理删除，应添加一个标志位，以防用户后悔时无法恢复
   - 数据添加是否有效的标识位
   - 字段排序 将数据库字段按照一定的规则进行排序，方便查找
   - 是否需要记录时间，创建时间和更新时间等
   - 数据库字段尽可能添加默认值
   - 如果两个表存在多对多的关系，尽可能在添加一张关联表，将其转化为一对多的关系
   - 表的垂直拆分，经常查询的字段放置到一个表中，把text， blob类型的数据拆分到另一个表中
   - 禁止使用select (*)这样的查询

   索引：
    索引需要根据where groupby等语句后的条件按照一定的顺序进行排列
    索引的个数需要控制在3个以内
    对于字符串索引，需要添加索引的长度控制，防止索引太大，占据太多空间

索引的弊端: 一是创建索引要耗费时间，二是索引要占有大量磁盘空间，三是增加了维护代价（在修改带索引的数据列时索引会减缓修改速度）

3. Mysql数据库有哪几种引擎，各自的特性是什么

+-------------+------+----------------------+-------------------------------+------------------------+
| 存储引擎    | 事务 | 锁粒度               | 主要应用                      | 忌用                   |
+=============+======+======================+===============================+========================+
| MyISAM      | No   | 支持并发插入的表级锁 | SELECT，INSERT                | 读写操作频繁           |
+-------------+------+----------------------+-------------------------------+------------------------+
| MRG-MyISAM  | No   | 支持并发插入的表级锁 | 分段归档，数据仓库            | 全局查找过多的场景     |
+-------------+------+----------------------+-------------------------------+------------------------+
| Innodb      | Yes  | 支持MVCC级别的行级锁 | 事务处理                      | 无                     |
+-------------+------+----------------------+-------------------------------+------------------------+
| Archine     | No   | 行级锁               | 日记记录，只支持insert select | 需要随机读取 更新 删除 |
+-------------+------+----------------------+-------------------------------+------------------------+
| NDB Cluster | Yes  | 行级锁               | 高可用                        | 大部分应用             |
+-------------+------+----------------------+-------------------------------+------------------------+

Innodb引擎提供了对数据库ACID事务的支持，并且实现了SQL标准的四种隔离级别，关于数据库事务与其隔离级别的内容请见数据库事务与其隔离级别这篇文章。该引擎还提供了行级锁和外键约束，它的设计目标是处理大容量数据库系统，它本身其实就是基于MySQL后台的完整数据库系统，MySQL运行时Innodb会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎不支持FULLTEXT类型的索引，而且它没有保存表的行数，当SELECT COUNT(*) FROM TABLE时需要扫描全表。当需要使用数据库事务时，该引擎当然是首选。由于锁的粒度更小，写操作不会锁定全表，所以在并发较高时，使用Innodb引擎会提升效率。但是使用行级锁也不是绝对的，如果在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表

MyIASM是MySQL默认的引擎，但是它没有提供对数据库事务的支持，也不支持行级锁和外键，因此当INSERT(插入)或UPDATE(更新)数据时即写操作需要锁定整个表，效率便会低一些。不过和Innodb不同，MyIASM中存储了表的行数，于是SELECT COUNT(*) FROM TABLE时只需要直接读取已经保存好的值而不需要进行全表扫描。如果表的读操作远远多于写操作且不需要数据库事务的支持，那么MyIASM也是很好的选择

大尺寸的数据集趋向于选择InnoDB引擎，因为它支持事务处理和故障恢复。数据库的大小决定了故障恢复的时间长短，InnoDB可以利用事务日志进行数据恢复，这会比较快。主键查询在InnoDB引擎下也会相当快，不过需要注意的是如果主键太长也会导致性能问题，关于这个问题我会在下文中讲到。大批的INSERT语句(在每个INSERT语句中写入多行，批量插入)在MyISAM下会快一些，但是UPDATE语句在InnoDB下则会更快一些，尤其是在并发量大的时候

InnoDB：磁盘表，支持事务，支持行级锁，B+Tree索引
ps:优点： 具有良好的ACID特性。适用于高并发，更新操作比较多的表。需要使用事务的表。对自动灾难恢复有要求的表。
缺点：读写效率相对MYISAM比较差。占用的磁盘空间比较大。

MyISAM：磁盘表，不支持事务，支持表级锁，B+Tree索引
ps: 优点：占用空间小，处理速度快（相对InnoDB来说）
缺点：不支持事务的完整性和并发性

MEMORY(Heap)：内存表，不支持事务，表级锁，Hash索引，不支持Blob,Text大类型
ps: 优点：速度要求快的，临时数据
缺点：丢失以后，对项目整体没有或者负面影响不大的时候。

4. 其他
    useServerPrestmts=true 开启PreparedStatemeng的缓存

## 2.nosql

1. 什么是nosql

2. 为什么nosql比sql快？
    Nosql是非关系型数据库，因为不需要满足关系数据库数据一致性等复杂特性所以速度快；
    sql是关系型数据库，功能强大，但是效率上有瓶颈


### 2.1 高效的key-Value存储

    常见的kv存储又： levelDB，RocksDB, InnoDb, TiDB
    RocksDB在levelDB的基础上进行开发
    TiDB的底层存储又使用的是RocksDB


## 3. Mysql

1. select ... for update

    ```
    排他锁的申请前提：没有线程对该结果集中的任何行数据使用排他锁或共享锁，否则申请会阻塞。

    for update仅适用于InnoDB，且必须在事务块(BEGIN/COMMIT)中才能生效。
    在进行事务操作时，通过“for update”语句，MySQL会对查询结果集中每行数据都添加排他锁，其他线程对该记录的更新与删除操作都会阻塞。排他锁包含行锁、表锁
    ```
2. select ... for update 是row lock or table lock

    ```
    1. 明确主键，并且有数据，则为row lock
    2. 明确主键，但是无数据，则no lock
    3. 无主键，但是有数据， 则为table lock
    4. 主键不明确，例如使用了id <> 3 or id like '%3',则为table lock
    ```
3. Mysql 锁分类和作用
    - Innodb的锁模式实际可以分为四种： 排他锁(x),共享锁(S), 意向排他锁(IX), 意向共享锁(IS)

        ```
        对于表锁：
        LOCK TABLE my_tabl_name READ;  用读锁锁表，会阻塞其他事务修改表数据。
        LOCK TABLE my_table_name WRITe; 用写锁锁表，会阻塞其他事务读和写

        对于行锁：
        共享锁，一个事务对一行的共享只读锁。
        排它锁，一个事务对一行的排他读写锁。

        例子如下：
        事务A锁住了表中的一行，让这一行只能读，不能写。 之后，事务B申请整个表的写锁。
        但读锁和写锁是有冲突的，那么如何判断当前表中的锁申请有冲突呢
        1. 判断表中的每一行是否有被行锁锁住
        2. 判断表是否已经被其他事务用表锁锁住

        使用方式1很明显是不合理的，性能消耗太严重，因此有了意向锁。
        当事务申请行锁时，首先向表申请意向锁，然后在申请行锁
        当申请的是表锁时，因为本身就是表锁，因此无需意向锁来表示该表的锁情况

        IS，IX 意向锁是表级的锁，

        如果一个事务请求的锁模式与当前的锁兼容，InnoDB就将请求的锁授予该事务；反之，如果两者不兼容，该事务就要等待锁释放。
        意向锁是InnoDB自动加的，不需用户干预。对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)；对于普通SELECT语句，InnoDB不会加任何锁；事务可以通过以下语句显示给记录集加共享锁或排他锁。
        共享锁（S）：SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE
        排他锁（X)：SELECT * FROM table_name WHERE ... FOR UPDATE
        ```

    - 间隙锁
        锁加在不存在的空闲空间，可以是两个索引记录之间，也可能是第一个索引记录之前或最后一个索引之后的空间,主要作用是在RR模式下，可以防止幻读, 通过修改隔离级别为读已提交来避免死锁
        ```
        间隙锁的出现主要集中在同一个事务中先delete后 insert的情况下， 当我们通过一个参数去删除一条记录的时候， 
        如果参数在数据库中存在，那么这个时候产生的是普通行锁，锁住这个记录， 然后删除， 然后释放锁。如果这条记录不存在，
        问题就来了， 数据库会扫描索引，发现这个记录不存在， 这个时候的delete语句获取到的就是一个间隙锁，
        然后数据库会向左扫描扫到第一个比给定参数小的值，向右扫描扫描到第一个比给定参数大的值， 然后以此为界，
        构建一个区间， 锁住整个区间内的数据， 一个特别容易出现死锁的间隙锁诞生了

            表数据：
            Id           taskId
            1              2
            3              9
            10            20
            40            41

            taskId是一个普通索引列

            开启一个会话： session 1
            sql> set autocommit=0; ## 取消自动提交 
            sql> delete from task_queue where taskId = 20;(数据存在)
            sql> insert into task_queue values(20, 20);

            在开启一个会话： session 2
            sql> set autocommit=0; ## 取消自动提交
            sql> delete from task_queue where taskId = 25;(数据不存在)
            sql> insert into task_queue values(30, 25);

            并发情况下，执行顺序可能为
            sql> delete from task_queue where taskId = 20;
            sql> delete from task_queue where taskId = 25;
            sql> insert into task_queue values(20, 20);
            sql> insert into task_queue values(30, 25);

            此时session 1 会形成20 到 41之间的间隙锁, session 2 也会造成20-40之间的间隙锁,造成了随后的死锁。

            ??猜测mysql解决方法，将其中一个事务的锁升级为写锁，然后另一个事务进入等待阶段

        间隙锁的产生：在事务中进行delete操作时会产生间隙锁(操作的时普通索引而非唯一索引或主键)， 在用select .. for update进行范围查询时，会产生间隙锁, 

        因此为了防止间隙锁的干扰，一，可以调整事务级别，由RR改为RC。
        或者对于修改操作尽可能使用唯一索引或者主键索引，对于查询，尽可能使用相等条件查询(需要注意的是如果使用相等条件查询，但记录不存在，也会产生间隙锁)
        
        ```

4. mysql 死锁以及如何避免

    * 如果一个事务select ... in share mode获得共享锁，但是如果当前事务也需要对该记录进行更新操作，那么很容易产生死锁。 因此对于锁定记录后需要进行更新的操作，应当使用select .. for update 获得 排他锁, 即一次性申请足够的锁
    ```
        T1:
        begin tran
        select * from table (share lock) 
        update table set column1='hello'

        T2:
        begin tran
        select * from table(share lock)
        update table set column1='world'

        假设T1和T2同时达到select，T1对table加共享锁，T2也对加共享锁，当
        T1的select执行完，准备执行update时，根据锁机制，T1的共享锁需要升
        级到排他锁才能执行接下来的update.在升级排他锁前，必须等table上的
        其它共享锁释放，但因为sharelock这样的共享锁只有等事务结束后才释放，
        所以因为T2的共享锁不释放而导致T1等(等T2释放共享锁，自己好升级成排
        他锁），同理，也因为T1的共享锁不释放而导致T2等。死锁产生了。
    ```

    * 多个不同的应用程序并发存取多个表时，保证每个线程按照固定的顺序申请表资源，可降低死锁概率
    * 在程序以批量方式处理数据的时候，如果事先对数据排序，保证每个线程按固定的顺序来处理记录，也可以大大降低出现死锁的可能

    * 在 repeatable-read模式下，如果两个线程同时使用select .. for update 加排他锁，如果资源不存在，那么都会加锁成功，记录不存在，试图添加一条记录，如果两个线程都这么做，那么会产生死锁，这种情况下可以将事务级别改为repeatable-commit，避免死锁问题
    
    * 当隔离级别为READ COMMITTED时，如果两个线程都先执行SELECT...FOR UPDATE，判断是否存在符合条件的记录，如果没有，就插入记录。此时，只有一个线程能插入成功，另一个线程会出现锁等待，当第1个线程提交后，第2个线程会因主键重出错，但虽然这个线程出错了，却会获得一个排他锁。这时如果有第3个线程又来申请排他锁，也会出现死锁。对于这种情况，可以直接做插入操作，然后再捕获主键重异常，或者在遇到主键重错误时，总是执行ROLLBACK释放获得的排他锁。 ???



5. 索引建立以及优化
    索引分为三类：
        - 普通索引 
            由key或index定义用来加快数据的查询速度，应只为那些经常出现的查询条件或者排序条件(order by)创建索引
        - 唯一索引 避免数据出现重复
        - 主索引 同唯一索引，主要区别是使用primary修饰






参考文档： [Mysql 锁详情](https://www.cnblogs.com/luyucheng/p/6297752.html)
