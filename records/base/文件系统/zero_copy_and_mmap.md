# 零拷贝和内存映射

## 1. 概念解释

### 1.1 Mmap 文件内存映射

我们常规的文件加载通常需要经过两次拷贝，1-通过DMA从磁盘加载到页缓存（内核空间）2-通过CPU从页缓存加载到内存（用户态内存），``mmap`` 是用来对以上两次缓存做优化，使两次拷贝变为1次

``mmap`` ：文件映射就是将程序虚拟页面直接映射到页缓存上，这样就无需有内核态再往用户态的拷贝，而且也避免了重复数据的产生。并且也不必再通过调用read或write方法对文件进行读写，可以通过映射地址加偏移量的方式直接操作

``mmap`` 的映射过程：
 (一) 进程启动映射过程，并在虚拟地址空间中为映射创建虚拟映射区域
（二）调用内核空间的系统调用函数mmap（不同于用户空间函数），实现文件物理地址和进程虚拟地址的一一映射关系
（三）进程发起对这片映射空间的访问，引发缺页异常，实现文件内容到物理内存（主存）的拷贝

映射是指硬盘上文件 的位置与进程 逻辑地址空间 中一块大小相同的区域之间的一一对应，这种对应关系纯属是逻辑上的概念，物理上是不存在的，原因是进程的逻辑地址空间本身就是不存在的。在内存映射的过程中，并没有实际的数据拷贝，文件没有被载入内存，只是逻辑上被放入了内存

mmap()会返回一个指针ptr，它指向进程逻辑地址空间中的一个地址，这样以后，进程无需再调用read或write对文件进行读写，而只需要通过ptr就能够操作文件。但是ptr所指向的是一个逻辑地址，要操作其中的数据，必须通过MMU将逻辑地址转换成物理地址,MMU在地址映射表中是无法找到与ptr相对应的物理地址的，也就是MMU失败，将产生一个缺页中断，缺页中断的中断响应函数会在swap中寻找相对应的页面，如果找不到（也就是该文件从来没有被读入内存的情况），则会通过mmap()建立的映射关系，从硬盘上将文件读取到物理内存中

如果在拷贝数据时，发现物理内存不够用，则会通过虚拟内存机制（swap）将暂时不用的物理页面交换到硬盘上

因此 通过Mmap映射的文件与实际的物理内存大小无关，最终回通过MMU来处理

### 1.2 零拷贝

利用 ``mmap``, 通过系统内核的 ``sendfile`` 方法，实现了从页缓存直接拷贝到目的出口，在系统中只存在一份数据
零拷贝的 ``零`` 是指用户态和内核态间copy数据的次数为零。

传统的数据copy（文件到文件、client到server等）涉及到四次用户态内核态切换、四次copy。四次copy中，两次在用户态和内核态间copy需要CPU参与、两次在内核态与IO设备间copy为DMA方式不需要CPU参与。零拷贝避免了用户态和内核态间的copy、减少了两次用户态内核态间的切换。

零拷贝可以提高数据传输效率，但对于需要在用户传输过程中对数据进行加工的场景（如加密）就不适合使用零拷贝

## 2. 文件传输

以网络传输文件为例：

### 2.1 常规传输

- 经历的过程为： 磁盘 -》(DMA Copy) 页缓存 -》（CPU Copy） 内存 （CPU Copy）-》 SockerBuffer -》(DMA Copy) 网卡
- 需要经历四次上下文切换 (从用户态到内核态，读取完在切回来-》两次  写入到SocketBuffer， 从用户态到内核态，写完在切回来-》两次)
- 4次拷贝(磁盘文件 DMA 拷贝到内核缓冲区，内核缓冲区 CPU 拷贝到用户缓冲区，用户缓冲区 CPU 拷贝到 Socket 缓冲区，Socket 缓冲区 DMA 拷贝到协议引擎)
- 保存3份数据（不算磁盘和网卡, 页缓存一份，内存一份，socketBuffer一份）


### 2.2 使用mmap进行传输

- 经历的过程为： 磁盘 -》(DMA Copy) 页缓存 -》（CPU Copy） SockerBuffer -》(DMA Copy) 网卡,建立内存在页缓存的映射，直接操纵页缓存到SockerBuffer
- 需要经历四次上下文切换 (从用户态到内核态，读取完在切回来-》两次  写入到SocketBuffer， 从用户态到内核态，写完在切回来-》两次)
- 3 次拷贝（磁盘文件DMA拷贝到内核缓冲区，内核缓冲区 CPU 拷贝到 Socket 缓冲区，Socket 缓冲区 DMA 拷贝到协议引擎）
- 保存2份数据（页缓存一份，socketBuffer一份）

### 2.3 linux 2.1版本的零拷贝 sendfile

经历的过程为： 磁盘 -》(DMA Copy) 页缓存 -》（CPU Copy） SockerBuffer -》(DMA Copy) 网卡

- 建立内存在页缓存的映射，直接操纵页缓存到SockerBuffer
- 需要经历两次上下文切换 (从用户态到内核态，读取完在切回来-》两次 )
- 3 次拷贝
- 保存2份数据（页缓存一份，socketBuffer一份）

### 2.4 linux 2.4之后的零拷贝 sendfile

经历的过程为： 磁盘 -》(DMA Copy) 页缓存 -》（CPU Copy 只拷贝文件描述符） SockerBuffer -》(DMA Copy) 网卡

- 建立内存在页缓存的映射，通过带收集功能的DMA，直接操纵页缓存到网卡

- 需要经历两次上下文切换 (从用户态到内核态，读取完在切回来-》两次 )
- 2 次拷贝（磁盘文件 DMA 拷贝到内核缓冲区，内核缓冲区 DMA 拷贝到协议引擎）
- 保存1份数据（页缓存一份）

## 3. 语言实现

### 3.1 java

``零拷贝`` Java 中FileChannal.transferTo() 底层用的就是sendfile

``mmap`` java中的FileChannel，提供了map和force方法，map创建文件和内存的映射,force用来刷新数据到磁盘

### 3.2 go

``io.Copy`` 底层封装了对 ``sendfile`` 的使用



## 4. 示例

### 4.1 kafka

在Producer端，使用了顺序写入磁盘的功能，保证数据的高效存储，
在Consumer端，使用了零拷贝，提高了数据的消费速度


## 5. 参考链接

[Kafka 和 RocketMQ 底层存储之那些你不知道的事](https://xie.infoq.cn/article/24b51de341d66de6d1e737d65)
[java零拷贝](https://www.cnblogs.com/z-sm/p/6547709.html)

[Mmap内存映射详解](https://blog.csdn.net/baidu_33621692/article/details/62891817)
