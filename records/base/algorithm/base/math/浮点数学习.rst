.. highlight:: rst

.. _records_base_pice_float_double_learn:

32位浮点数
===============

无论是单精度还是双精度在存储中都分为三个部分:

    - 符号位(Sign) : 0代表正，1代表为负
    - 指数位（Exponent）:用于存储科学计数法中的指数数据，并且采用移位存储
    - 尾数部分（Mantissa）：尾数部分

32位浮点数
::::::::::::::::

float : 1(符号为) + 8 （指数位） + 23(尾数位)
double（双精度）:1(符号为) + 11 （指数位） + 52(尾数位) 


32位浮点数(float): 按 IEEE 标准，最大数值范围 是正负 3.40282e+038 。有效数字精度是 6 到 7 位 （十进制）


十进制数转二进制数
::::::::::::::::::::

步骤
'''''''

::

    1 改写整数部分 以数值5.2为例。先不考虑指数部分，我们先单纯的将十进制数改写成二进制。整数部分很简单，5.即101.。

    2 改写小数部分 小数部分我们相当于拆成是2^-1一直到2^-N的和。
    例如：0.2 = 0.125+0.0625+0.007825+0.00390625即2^-3+2^-4+2^-7+2^-8….，也即.00110011001100110011

    3 规格化 现在我们已经有了这么一串二进制101.00110011001100110011。然后我们要将它规格化，也叫Normalize。
    其实原理很简单就是保证小数点前只有一个bit。于是我们就得到了以下表示：1.0100110011001100110011 * 2^2。
    到此为止我们已经把改写工作完成，接下来就是要把bit填充到三个组成部分中去了。

    4 填充 指数部分（Exponent）：之前说过需要以127作为偏移量调整。因此2的2次方，指数部分偏移成2+127即129，表示成10000001填入。
    整数部分（Mantissa）：除了简单的填入外，需要特别解释的地方是1.010011中的整数部分 ``1`` 在填充时被舍去了。因为规格化后的数值整部部分总是为1。


十进制小数转二进制
'''''''''''''''''''''

算法是乘以2直到没有了小数为止。举个例子，0.9表示成二进制数
                     0.9*2=1.8   取整数部分  1
                     0.8(1.8的小数部分)*2=1.6    取整数部分  1
                     0.6*2=1.2   取整数部分  1
                     0.2*2=0.4   取整数部分  0
                     0.4*2=0.8   取整数部分  0
                     0.8*2=1.6   取整数部分  1
                     0.6*2=1.2   取整数部分  0
                     .........      0.9二进制表示为(从上往下): 1100100100100......

   注意：上面的计算过程循环了，也就是说*2永远不可能消灭小数部分，这样算法将无限下去。很显然，小数的二进制表示有时是不可能精确的 。
   其实道理很简单，十进制系统中能不能准确表示出1/3呢？同样二进制系统也无法准确表示1/10。这也就解释了为什么浮点型减法出现了"减不尽"的精度丢失问题。


TIP:

::

    1.010011和0.010011 如何区分？

    AS： 0.010011 可以改写成 1.010011 * 2^(-2), 省略小数的也不会造成两个小数点混淆
