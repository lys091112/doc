.. highlight: rst

进程与线程的空间问题
---------------------

在linux下每个进程单独占有4G的虚拟地址空间，而这个进程下的所有线程共享着它的地址空间, 具体的解释如下:

早期的内存管理机制
=====================
在早期的计算机中，程序都是直接运行在内存上的，也就是说程序中访问的内存地址都是实际的物理内存地址。

    当计算机同时运行多个程序时，必须保证这些程序用到的内存总量要小于计算机实际物理内存的大小。那当程序同时运行多个程序时，操作系统顺次向下分配物理内存地址.
    
    例如一台计算机的内存大小是128M，现在同时运行程序A和B，A需占用内存30M，B需占用内存60M。计算机在给程序分配内存时先将内存中的前30M分配给程序A，接着再从内存中剩余的98M中划分出60M分配给程序B。这种分配方法可以保证程序A和程序B都能运行，但是这种简单的内存分配策略问题很多。
        
        - 首先进程地址空间不隔离。由于程序都是直接访问物理内存，恶意程序可以很容统修改别的进程的内存数据，以达到破坏的目的。即使是非恶意的，但是有bug的程序也可能不小心修改了其它程序的内存数据，就会导致其它程序的运行出现异常。其中一个任务失败了，可能也会影响其它的任务。

        - 其次是程序运行的地址不确定。当内存中的剩余空间可以满足程序C的要求后，操作系统会在剩余空间中随机分配一段连续的20M大小的空间给程序C使用，因为是随机分配的，所以程序运行的地址是不确定的。内存使用效率低。在A和B都运行的情况下，如果用户又运行了程序C，而程序C需要20M大小的内存才能运行，而此时系统只剩下8M的空间可供使用，所以此时系统必须在已运行的程序中选择一个将该程序的数据暂时拷贝到硬盘上，释放出部分空间来供程序C使用，然后再将程序C的数据全部装入内存中运行。可以想象得到，在这个过程中，有大量的数据在装入装出，导致效率十分低下

虚拟地址
==========
为了解决上述问题，人们设计了间接的地址访问方法访问物理内存。按照这种方法，程序中访问的内存地址不再是实际的物理内存地址，而是一个虚拟地址，然后由操作系统将这个虚拟地址映射到适当的物理内存地址上。这样，只要操作系统处理好虚拟地址到物理内存地址的映射，就可以保证不同的程序最终访问的内存地址位于不同的区域，彼此没有重叠，就可以达到内存地址空间隔离的效果

当创建一个进程时，操作系统会为该进程分配一个4GB大小的虚拟进程地址空间。之所以是4GB，是因为在32位的操作系统中，一个指针长度是4字节（64位系统是8字节，由cpu的寻址位数决定），而4字节指针的寻址能力是从0x00000000~0xFFFFFFFF，最大值0xFFFFFFFF表示的即为4GB大小的容量。与虚拟地址空间相对的，还有一个物理地址空间，这个地址空间对应的是真实的物理内存。如果你的计算机上安装了1G大小的内存，那么这个物理地址空间表示的范围是0x00000000~0x3FFFFFFF。当操作系统做虚拟地址到物理地址映射时，只能映射到这一范围。当进程创建时，每个进程都会有一个自己的4GB虚拟地址空间。

要注意的是这个4GB的地址空间是“虚拟”的，并不是真实存在的，而且每个进程只能访问自己虚拟地址空间中的数据，无法访问别的进程中的数据，通过这种方法实现了进程间的地址隔离。实际上也是增加了地址空间，在这4G中还分为用户空间和系统空间，用户态时候进程只能访问用户空间（内核态时候既可以访问用户空间也可以访问系统空间）。

这只是解决了地址问题，实际进程的运行还是要在真实的内存上，所以，必须在虚拟地址与物理地址间建立一种映射关系。这样，通过映射机制，当程序访问虚拟地址空间上的某个地址值时，就相当于访问了物理地址空间中的另一个值。人们采用分段(Sagmentation)的方法，它的思想是在虚拟地址空间和物理地址空间之间做一一映射。比如说虚拟地址空间中某个10M大小的空间映射到物理地址空间中某个10M大小的空间。这种思想理解起来并不难，操作系统保证不同进程的地址空间被映射到物理地址空间中不同的区域上，这样每个进程最终访问到的物理地址空间都是彼此分开的。通过这种方式，就实现了进程间的地址隔离。在做开发时，开发人员只需访问这段虚拟区间上的地址即可。应用程序并不关心进程的这段地址究竟被映射到物理内存的那块区域上了，所以程序的运行地址也就是相当于说是确定的了。

但是这种分段的映射方法并没有解决内存的使用效率问题。在分段的映射方法中，每次换入换出内存的都是整个程序，这样会造成大量的磁盘访问操作，导致效率低下。基于这种情况，人们想到了内存分割和映射方法，这种方法就是分页(Paging)


分页存储
=============

分页的基本方法是，将地址空间分成许多的页。每页的大小由CPU决定，然后由操作系统选择页的大小。目前Inter系列的CPU支持4KB或4MB的页大小，而PC上目前都选择使用4KB。按这种选择，4GB虚拟地址空间共可以分成1048576个页，512M的物理内存可以分为131072个页。显然虚拟空间的页数要比物理空间的页数多得多。 在分段的方法中，每次程序运行时总是把程序全部装入内存，而分页的方法则有所不同。分页的思想是程序运行时用到哪页就为哪页分配内存，没用到的页暂时保留在硬盘上。当用到这些页时再在物理地址空间中为这些页分配内存，然后建立虚拟地址空间中的页和刚分配的物理内存页间的映射。用这样的方法程序可以使用一系列虚拟地址来访问大于可用物理内存的内存缓冲区。当物理内存的供应量变小时，内存管理器会将物理内存页（通常大小为 4 KB）保存到磁盘文件。数据或代码页会根据需要在物理内存与磁盘之间移动。这具体和系统对内存的管理和对进程的调度有关


``TIP:`` 在32位系统下，进程的内存大小被限制在了4G，无法通过其他方式被扩大
