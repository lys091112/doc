# 一些基础的算法记录

1. LRU (最近最少使用缓存算法)

```
    用一个特殊的栈来保存当前正在使用的各个页面的页面号。
    当一个新的进程访问某页面时，便将该页面号压入栈顶，其他的页面号往栈底移，
    如果内存不够，则将栈底的页面号移除。这样，栈顶始终是最新被访问的页面的编号
    ，而栈底则是最近最久未访问的页面的页面号

    例如栈空间为3,页面数据为[1,3,2,3,5,6,8,2]
    那么栈空间数据为:
    1
    1 3
    1 3 2
    1 2 3
    2 3 5
    3 5 6
    5 6 8
    6 8 2
    即每次淘汰掉最近最少使用的那份数据
```

2. SJF (短作业优先 , Shortest Job First)

```
短作业优先调度算法基于这样一种思想： 
运行时间短的优先调度； 
如果运行时间相同则调度最先发起请求的进程。 
等待时间：一个进程从发起请求到开始执行的时间间隔。 

到达时间 0 1 2 4
运行时间 4 3 2 5

完成时间 4 9 6 14
周转时间 0 8 4 10
```

3. Tier 的使用

```
第一个问题： 一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析。

    海量数据处理面试题集锦与Bit-map详解中给出的参考答案：用trie树统计每个词出现的次数，时间复杂度是O(n*le)（le表示单词的平均长度），然后是找出出现最频繁的前10个词。也可以用堆来实现(寻找最小的k个数），时间复杂度是O(n*lg10)。所以总的时间复杂度，是O(n*le)与O(n*lg10)中较大的哪一个
    O(n * lg10)来源：从trie中取出10个元素，进行堆排序（建堆的时间复杂度为O(n)），然后获取元素所用时间为lg10（TOP10小，用最大堆，TOP10大，用最小堆），假设为最小堆
    取最大值，遍历trie，如果下一个元素比堆顶即最小值大，那么替换堆顶并排序，时间为lg10，然后依次遍历，总计n次，因此一共需要时间为O(n*lg10)

```

4. 一致性Hash

```
    性质：考虑到分布式系统每个节点都有可能失效，并且新的节点很可能动态的增加进来，如何保证当系统的节点数目发生变化时仍然能够对外提供良好的服务，这是值得考虑的，尤其实在设计分布式缓存系统时，如果某台服务器失效，对于整个系统来说如果不采用合适的算法来保证一致性，那么缓存于系统中的所有数据都可能会失效（即由于系统节点数目变少，客户端在请求某一对象时需要重新计算其hash值（通常与系统中的节点数目有关），由于hash值已经改变，所以很可能找不到保存该对象的服务器节点），因此一致性hash就显得至关重要
    原理：
    1. 一致性哈希将整个哈希值空间组织成一个虚拟的圆环，如假设某哈希函数H的值空间为0-2^32-1（即哈希值是一个32位无符号整形）
    2.  各个服务器使用Hash进行一个哈希，具体可以选择服务器的ip或主机名作为关键字进行哈希，这样每台机器就能确定其在哈希环上的位置
    3. 确定此数据在环上的位置后，从此位置沿环顺时针“行走”，第一台遇到的服务器就是其应该定位到的服务器
    因此，当一个节点异常或者添加一个新的节点时，影响的只是这个节点与上一个节点之间的数据
```
5. 倒排索引
