# 数据库事务四大特性以及隔离级别


### 四大特性（ACID）

* **原子性** (Atomicity)

   <p> 原子性是指事务包含的一些列操作，要不全部成功，要不回滚。重要的是如果操作失败，不会对数据库有任何影响

* **一致性**（Consistency)

    <p> 一致性是指数据库从一个一致性状态转移到另一个一致性状态。

    > 例如：转账， A和B两者钱加起来一共是500，那么进故宫一个事务后，他们的金额总和仍为500，事务不应该改变
    > 两者的金额总和这个状态。

* **隔离性** (Isolation)

   <p> 隔离性是指当多个用户并发访问数据库时，例如操作同一个表，那么数据库会为每个连接开启一个事务，且不会憋
    其他事务所干扰，多个事务之间相互隔离。

* **持久性**（Durability)

    <p> 持久性是指一个事务一旦提交了，那么对于数据库的改变是永久性的，即便数据库出现故障情况下一步会丢失
    已经提交的事务。

    > 例如: 我们提交一个事务，当数据库出现问题，那么操作提示说事务完成，那么即便数据库出现故障，一
    > 必须保证事务执行完成，否则会出现数据库提示事务完成，却因故障而没有执行事务。 也因此需要保证
    > 只有事务真正执行完成后，才给予提示说事务完成。


### 数据库隔离级别

* **脏读**

    <p> 脏读是指在一个事务里读取了另一个事务未提交的数据

    > 例如： 当一个事务在执行过程中多次修改某数据，但该事务还未提交，此时又另一个事务对该数据进行了
    > 修改，并进行提交，那么此时会造成两个事务得到的数据不一致问题。 如A行B转账100元，此时B进行读取
    > 数据库，发现转帐已经到账，但由于A事务没有进行事务提交，造成事务回滚，此时B再次进行查看时，发现
    > 转账并没有进行。
   
* **不可重复读**

    <p> 不可重复读是指：指在一个事务中，多次查询某数据却返回了不同的值。这是因为在事务过程中，该数据
    被另一个事务修改了。

    不可重复读和脏读的区别是：一个是读取了未提交的事务数据，一个是读取了已提交的事务数据，
    通常情况下，不可重复读没有任何问题，

* **幻读（虚读）**

    <p>  幻读是非独立事务执行时发生的一种现象，例如事务A修改数据库摸个数据项从a变为b，此时事务B新
    插入一条数据，并把这个a提交给了数据库，那么事务A会发现有一个数据没有修改，这行是因为事务B的添加
    造成的，而对于事务A就发生了欢读。

    幻读和不可重复读都是读取的另一条已经提交的事务，而脏读读取的事还没提交的事务，不可重复读是针对的
    一行数据，而幻读针对的是一批数据。

不可重复读和幻读的区别在于一个是修改或删除操作，一个是添加操作， 如果要避免不可重复读
，那么需要添加行级锁，是数据不会被更新，如果要避免幻读，那么需要添加表级锁

### mysql 默认的四种隔离级别

| 隔离级别|脏读|不可重复读|幻读|
|------|----|---|---|
|串行化（Serializable）|N|N|N|
|可重复读（Repeatable)(Default)|N|N|Y|
|读已提交（Read Commited）|N|Y|Y|
|读未提交（Read Uncommited）|Y|Y|Y|

**可重复读会发生幻读**：即可以保证在改事务执行过程中不会有其他事务进行修改，但无法
保证其他事务不对数据库进行增加。
**读已**: 提交保证读取到的数据都是已经提交的事务。


//TODO
mysql数据库的一些基本命令，以及事务实例实现

## 乐观锁， 悲观锁

乐观锁更适合解决冲突概率极小的情况；而悲观锁则适合解决并发竞争激烈的情况，尽量用行锁，缩小加锁粒度，以提高并发处理能力，即便加行锁的时间比加表锁的要长

悲观锁（Pessimistic Concurrency Control，PCC）：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。至于怎么加锁，加锁的范围也没讲。

乐观锁（Optimistic Concurrency Control，OCC）：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。也没具体指定怎么检查。

乐观锁不能解决脏读，加锁的时间要比悲观锁短（只是在执行sql时加了基本的锁保证隔离性级别），乐观锁可以用较大的锁粒度获得较好的并发访问性能。但是如果第二个用户恰好在第一个用户提交更改之前读取了该对象，那么当他完成了自己的更改进行提交时，数据库就会发现该对象已经变化了，这样，第二个用户不得不重新读取该对象并作出更改。
