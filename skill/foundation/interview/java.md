# Java

## JVM 优化
一些可能导致内存溢出的原因
    - 堆内存设置太小
    - 永久代设置太小(java8已不存在这个问题,因为metaspace已经替代了perm)
    - 代码中创建了很多大对象 , 且一直因为被引用不能被回收
    - 长生命周期对象持有短生命周期对象的引用
    - 静态集合类引起的内存泄漏 , 例如HashMap和Vector等  因为他们是静态的, 他们的生命周期与应用一致 , 所以他们引用的对象不会被释放 , 所以需要特别注意自己是否有静态集合存了许多对象的情况
    - 单例模式 单例对象初始化后再JVM整个生命周期中存在 , 如果单例对象持有对外部对象的引用那么整个对象不会被JVM回收
    - 全局集合
    - 类加载器 


1. 代码中创建了很多大对象 , 且一直因为被引用不能被回收

    0) 使用jstat查看gc情况
    1) 使用jmap -heap pid查看堆使用情况
    2) 使用jmap -histo:live pid 查看实例数和实例所占内存大小
    3) 第三步, 统计所有实例所占内存大小 jmap -histo:live 17863|awk ‘{if(NR>3)a+=\$3}END{print a}’ 


2.  java进程高负载问题排查

    - 执行top -c命令，找到cpu最高的进程的id
    - 使用top -H -p #{pid} 命令，查看当前java进程中的各线程的资源使用情况；
    - 找出负载高的线程，记录pid（26507）；
    - 使用printf "%x\n" 26507命令，将线程的pid（26507）转换为16进制字符串（678b）；
    - 在jstack -l pid 导出的java进程的堆栈信息中，查找字符串678b，即可定位负载高的线程的堆栈信息
